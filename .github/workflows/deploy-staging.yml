name: Deploy Frontend to GCP VM (Staging)

on:
  push:
    branches:
      - staging

env:
  PROJECT_ID: bh-opie
  IMAGE_NAME_FRONTEND: opie-frontend-staging

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: bh-opie-staging
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: GCP Authentication
        uses: google-github-actions/auth@v1
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'
          project_id: ${{ env.PROJECT_ID }}

      - name: Verify Service Account
        run: |
          echo "Current service account:"
          gcloud auth list --filter=status:ACTIVE --format="value(account)"
          echo "Project:"
          gcloud config get-value project
          echo "Testing basic GCP access:"
          gcloud projects describe ${{ env.PROJECT_ID }} --format="value(projectId)"

      - name: Set Project
        run: gcloud config set project ${{ env.PROJECT_ID }}

      - name: Verify Artifact Registry Access
        run: |
          echo "Testing Artifact Registry access..."
          gcloud artifacts repositories list --location=australia-southeast1 --project=${{ env.PROJECT_ID }}
          echo "Repository access verified!"
          
          # Additional verification - check if we can describe the specific repository
          echo "Checking specific repository access..."
          gcloud artifacts repositories describe containers-staging --location=australia-southeast1 --project=${{ env.PROJECT_ID }} || {
            echo "Repository 'containers-staging' not found, will create it during build step"
          }

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker australia-southeast1-docker.pkg.dev --quiet
          echo "Docker configured for Artifact Registry"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker image
        run: |
          IMAGE_FRONTEND=australia-southeast1-docker.pkg.dev/${PROJECT_ID}/containers-staging/${IMAGE_NAME_FRONTEND}:staging
          echo "Building and pushing Docker image: $IMAGE_FRONTEND"
          
          # Verify we can access the repository before building
          echo "Verifying repository access..."
          gcloud artifacts repositories describe containers-staging \
            --location=australia-southeast1 \
            --project=${PROJECT_ID} || {
            echo "Repository not found, creating it..."
            gcloud artifacts repositories create containers-staging \
              --repository-format=docker \
              --location=australia-southeast1 \
              --project=${PROJECT_ID}
          }
          
          # Build with cache and push in one step
          docker buildx build --builder default \
            --platform linux/amd64 \
            --build-arg NEXT_PUBLIC_DEFAULT_AGENT_ID="$NEXT_PUBLIC_DEFAULT_AGENT_ID" \
            --build-arg NEXT_PUBLIC_API_ORIGIN="$NEXT_PUBLIC_API_ORIGIN" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="$NEXT_PUBLIC_API_BASE_URL" \
            --build-arg NEXT_PUBLIC_NANGO_API_URL="$NEXT_PUBLIC_NANGO_API_URL" \
            --build-arg NEXT_PUBLIC_NANGO_BASE_URL="$NEXT_PUBLIC_NANGO_BASE_URL" \
            --build-arg COLLABORATION_WS_URL="$COLLABORATION_WS_URL" \
            --build-arg NEXT_PUBLIC_SENTRY_DSN="$NEXT_PUBLIC_SENTRY_DSN" \
            --build-arg SENTRY_AUTH_TOKEN="$SENTRY_AUTH_TOKEN" \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --push \
            -t "$IMAGE_FRONTEND" .
          
          echo "Docker image built and pushed successfully!"
        env:
          PROJECT_ID: ${{ env.PROJECT_ID }}
          IMAGE_NAME_FRONTEND: ${{ env.IMAGE_NAME_FRONTEND }}
          NEXT_PUBLIC_DEFAULT_AGENT_ID: ${{ vars.NEXT_PUBLIC_DEFAULT_AGENT_ID || '' }}
          NEXT_PUBLIC_API_ORIGIN: ${{ secrets.NEXT_PUBLIC_API_ORIGIN || '' }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8000' }}
          NEXT_PUBLIC_NANGO_API_URL: ${{ vars.NEXT_PUBLIC_NANGO_API_URL || '' }}
          NEXT_PUBLIC_NANGO_BASE_URL: ${{ vars.NEXT_PUBLIC_NANGO_BASE_URL || '' }}
          COLLABORATION_WS_URL: ${{ secrets.COLLABORATION_WS_URL || '' }}
          NEXT_PUBLIC_SENTRY_DSN: ${{ secrets.NEXT_PUBLIC_SENTRY_DSN || '' }}
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN || '' }}

      - name: Deploy on VM (single optimized step)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: github-actions-deploy-staging
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          timeout: 10m
          script_stop: true
          script: |
            # Set variables from environment
            PROJECT_ID=${{ env.PROJECT_ID }}
            IMAGE_NAME_FRONTEND=${{ env.IMAGE_NAME_FRONTEND }}
            IMAGE_FRONTEND=australia-southeast1-docker.pkg.dev/${PROJECT_ID}/containers-staging/${IMAGE_NAME_FRONTEND}:staging
            
            # Debug: Show the constructed image name
            echo "Constructed image name: $IMAGE_FRONTEND"
            
            # Create staging frontend directory if it doesn't exist
            mkdir -p ~/frontend-staging
            cd ~/frontend-staging
            
            # Verify we're in the correct directory
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -la
            
            # Create docker-compose.yml with correct image URL
            cat > docker-compose.yml << EOF
            version: '3.8'
            services:
              frontend:
                container_name: opie-frontend-staging
                image: $IMAGE_FRONTEND
                ports:
                  - "5174:3000"
                env_file:
                  - .env.frontend
                restart: unless-stopped
                environment:
                  - NODE_ENV=staging
            EOF
            
            # Create .env.frontend if it doesn't exist
            if [ ! -f .env.frontend ]; then
              echo "${{ secrets.ENV_FILE_CONTENTS }}" > .env.frontend
            fi
            
            # Verify docker-compose.yml was created correctly
            echo "Verifying docker-compose.yml:"
            cat docker-compose.yml
            echo "Current directory: $(pwd)"
            echo "Files in current directory:"
            ls -la
            
            echo "Authenticating with Artifact Registry..."
            
            # Get access token from VM's service account via metadata service
            ACCESS_TOKEN=$(curl -s -H 'Metadata-Flavor: Google' \
              'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token' \
              | jq -r '.access_token')
            
            if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then
              echo "Failed to get access token from metadata service"
              exit 1
            fi
            
            echo "Access token obtained"
            
            # Authenticate Docker with Artifact Registry using the access token
            echo "$ACCESS_TOKEN" | sudo docker login -u _dcgcloud_token \
              --password-stdin australia-southeast1-docker.pkg.dev
            
            if [ $? -eq 0 ]; then
              echo "Docker authentication successful"
            else
              echo "Docker authentication failed"
              exit 1
            fi
            
            # Authenticate with GCP (if not already done)
            if [ ! -f gcp-key.json ]; then
              echo '${{ secrets.GCP_SA_KEY }}' > gcp-key.json
              sudo gcloud auth activate-service-account --key-file=gcp-key.json
              sudo gcloud auth configure-docker australia-southeast1-docker.pkg.dev --quiet
            fi
            
            # Deploy with optimized commands
            echo "Final directory check before deployment:"
            echo "Current directory: $(pwd)"
            echo "Checking for docker-compose.yml:"
            if [ -f docker-compose.yml ]; then
              echo "✓ docker-compose.yml found"
              echo "Contents:"
              cat docker-compose.yml
            else
              echo "✗ docker-compose.yml not found!"
              echo "Directory contents:"
              ls -la
              exit 1
            fi
            
            echo "Pulling latest staging image..."
            sudo docker-compose pull --quiet
            
            echo "Stopping and removing old staging container..."
            sudo docker-compose down --remove-orphans || true
            
            echo "Starting new staging container..."
            sudo docker-compose up -d --remove-orphans
            
            echo "Cleaning up unused images..."
            sudo docker image prune -f
            
            echo "Staging deployment completed successfully!"
            
            # Force exit to close SSH session properly
            exit 0

